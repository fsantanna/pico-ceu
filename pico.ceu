type Point = [x:_int, y:_int]
type Size  = [w:_int, h:_int]
type Rect  = [pos:Point, size:Size]

type HAnchor = <Left  =(),Center=(),Right=()>
type VAnchor = <Bottom=(),Middle=(),Top  =()>

type Event = <
    Kill            = (),
    Task            = _uint64_t,
    Any             = (),
    Timeout         = (),
    Frame           = _int,
    Draw            = (),
    KeyDown         = _int,
    MouseButtonDown = [but:_int,pos:Point],
    MouseButtonUp   = [_int,Point],
    MouseMotion     = Point,
    Collided        = (),
    Pause           = _int,
    Hide            = _int
>

type Pico = <
    Delay           = _int,
    Event           = _int,
    Event_Timeout   = [_int,_int],
    Present         = (),
    Clear           = (),
    Draw_Pixel      = Point,
    Draw_Line       = [Point,Point],
    Draw_Rect       = Rect,
    Draw_Text       = [Point,_(char*)],
    Draw_Image      = [Point,_(char*)],
    Get_Size        = /Size,
    Set_Anchor      = [HAnchor,VAnchor],
    Set_Auto        = (),
    Set_Color_Clear = [_int,_int,_int,_int],
    Set_Color_Draw  = [_int,_int,_int,_int],
    Set_Cursor      = Point,
    Set_Font        = [_(char*),_int],
    Set_Grid        = _int,
    Set_Pan         = Point,
    Set_Size        = Size,
    Set_Title       = _(char*),
    Set_Zoom        = Size,
    Write           = _(char*),
    WriteLn         = _(char*)
>

-------------------------------------------------------------------------------

var isPointVsRect = func [pt:Point,r:Rect] -> _int {
    return not (or [ lt [pt.x, sub [r.x,rw]],
                or [ gt [pt.x, add [r.x,rw]],
                or [ lt [pt.y, sub [r.y,rh]],
                     gt [pt.y, add [r.y,rh]]]]])
        where {
            var pt = arg.pt
            var r  = arg.r.pos
            var rw = div [arg.r.size.w, _2]
            var rh = div [arg.r.size.h, _2]
        }
}

var isRectVsRect = func [r1:Rect,r2:Rect] -> _int {
    return (or [ isPointVsRect [p1,r1],
            or [ isPointVsRect [p2,r1],
            or [ isPointVsRect [p3,r1],
                 isPointVsRect [p4,r1]]]])
        where {
            var r1 = arg.r1
            var r2 = arg.r2
            var w2 = div [r2.size.w,_2]
            var h2 = div [r2.size.h,_2]
            var p1 = Point [sub[r2.pos.x,w2], sub[r2.pos.y,h2]]
            var p2 = Point [sub[r2.pos.x,w2], add[r2.pos.y,h2]]
            var p3 = Point [add[r2.pos.x,w2], add[r2.pos.y,h2]]
            var p4 = Point [add[r2.pos.x,w2], sub[r2.pos.y,h2]]
        }
}

var pico_loop = func () -> () {
    output pico Pico.Set_Auto _0
    var old: _int = _SDL_GetTicks ()
    loop {
        var now: _int = _SDL_GetTicks ()
        var dt   = sub [now,old]            -- dt   = now - old
        var togo = sub [_40, dt]            -- togo = 40 - dt
        if lte [togo,_0] {                  -- if togo<=0
            emit @GLOBAL Event.Frame _40
            output pico Pico.Clear
            emit @GLOBAL Event.Draw
            output pico Pico.Present
            set old = add [togo,now]
        } else {
            var e: Event = input pico Pico.Event_Timeout [_SDL_ANY,togo]
            if not e?Timeout {
                emit @GLOBAL e
            }
        }
    }
}

-------------------------------------------------------------------------------

native type _{
    void output_pico (CEU_Pico arg) {
        switch (arg.tag) {
            case CEU_PICO_SET_ANCHOR: {
                Pico_IO io = { CEU_PICO_SET_ANCHOR, .Set_Anchor = {arg.Set_Anchor._1.tag,arg.Set_Anchor._2.tag} };
                pico_output(io);
                break;
            }
            default:
                pico_output(*(Pico_IO*)&arg);
                break;
        }
    }

    int tosdl (int e) {
        switch (e) {
            case CEU_EVENT_ANY:              return SDL_ANY;
            //case CEU_EVENT_TIMEOUT:          return ???;
            case CEU_EVENT_KEYDOWN:          return SDL_KEYDOWN;
            case CEU_EVENT_MOUSEBUTTONDOWN:  return SDL_MOUSEBUTTONDOWN;
            case CEU_EVENT_MOUSEBUTTONUP:    return SDL_MOUSEBUTTONUP;
            case CEU_EVENT_MOUSEMOTION:      return SDL_MOUSEMOTION;
        }
        assert(0);
    }

    void toce (SDL_Event* e, CEU_Event* arg) {
        switch (e->type) {
            case SDL_KEYDOWN:
                *arg = (CEU_Event) { CEU_EVENT_KEYDOWN, { .KeyDown = e->key.keysym.sym } };
                break;
            case SDL_MOUSEBUTTONDOWN: {
                int bt = e->button.button;
                int x  = e->button.x;
                int y  = e->button.y;
                *arg = (CEU_Event) { CEU_EVENT_MOUSEBUTTONDOWN, { .MouseButtonDown = {bt,{x,y}} } };
                break;
            }
            case SDL_MOUSEBUTTONUP: {
                int bt = e->button.button;
                int x  = e->button.x;
                int y  = e->button.y;
                *arg = (CEU_Event) { CEU_EVENT_MOUSEBUTTONUP, { .MouseButtonUp = {bt,{x,y}} } };
                break;
            }
            case SDL_MOUSEMOTION: {
                int x  = e->button.x;
                int y  = e->button.y;
                *arg = (CEU_Event) { CEU_EVENT_MOUSEMOTION, { .MouseMotion = {x,y} } };
                break;
            }
        }
    }

    CEU_Event input_pico_Event (CEU_Pico arg) {
        SDL_Event e;
        switch (arg.tag) {
            case CEU_PICO_EVENT: {
                int ok = pico_input(&e, (Pico_IO) {PICO_EVENT,.Event=arg.Event});
                assert(ok);
                CEU_Event s;
                toce(&e, &s);
                return s;
            }
            case CEU_PICO_EVENT_TIMEOUT: {
                int ok = pico_input(&e, (Pico_IO) {
                    PICO_EVENT_TIMEOUT,
                    .Event_Timeout = { arg.Event_Timeout._1, arg.Event_Timeout._2 }
                });
                if (ok) {
                    CEU_Event s;
                    toce(&e, &s);
                    return s;
                } else {
                    return (CEU_Event) { CEU_EVENT_TIMEOUT };
                }
                break;
            }
        }
    }

    void input_pico_Unit (CEU_Pico arg) {
        SDL_Event e;
        switch (arg.tag) {
            case CEU_PICO_DELAY: {
                int ok = pico_input(&e, *((Pico_IO*)&arg));
                assert(ok);
                break;
            }
            default:
                input_pico_Event (arg);
                break;
        }
    }
}

call _pico_open ()
-- TODO: pico_close()
