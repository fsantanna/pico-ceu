type Point = [x:_int, y:_int]
type Size  = [w:_int, h:_int]
type Rect  = [pos:Point, size:Size]

type HAnchor = <Left  =(),Center=(),Right=()>
type VAnchor = <Bottom=(),Middle=(),Top  =()>

type Event += <
    Frame = _int
    Draw  = ()
    Key   = [key:_int] + <
        Down = ()
        Up   = ()
    >
    Mouse = [pos: Point] + <
        Button = [but: _int] + <
            Down = ()
            Up   = ()
        >
        Motion = ()
    >
>

type Output += <
    Pico = <
        Present = ()
        Clear   = ()
        Draw    = <
            Pixel = Point
            Line  = [Point,Point]
            Rect  = Rect
            Text  = [Point,_(char*)]
            Image = [Point,_(char*)]
        >
        Get = <
            Size = [size:/Size] + <
                Window = ()
                Image  = [path:_(char*)]
            >
        >
        Set = <
            Anchor      = [HAnchor,VAnchor]
            Auto        = ()
            Color = [r:_int,g:_int,b:_int,a:_int] + <
                Clear = ()
                Draw  = ()
            >
            Cursor      = Point
            Font        = [_(char*),_int]
            Grid        = _int
            Image = <
                Crop = Rect
                Size = Size
            >
            Pan         = Point
            Size        = Size
            Title       = _(char*)
            Zoom        = Size
        >
        Write = [text:_(char*)] + <
            Norm = ()
            Line = ()
        >
    >
>

type Input += <
    Pico = <
        Delay = _int
        Event = [id:_int] + <
            Forever = ()
            Timeout = [to:_int]
        >
    >
>

-------------------------------------------------------------------------------

func isPointVsRect: [pt:Point,r:Rect] -> _int {
    return not (or [ lt [pt.x, sub [r.x,rw]],
                or [ gt [pt.x, add [r.x,rw]],
                or [ lt [pt.y, sub [r.y,rh]],
                     gt [pt.y, add [r.y,rh]]]]])
        where {
            var pt = arg.pt
            var r  = arg.r.pos
            var rw = div [arg.r.size.w, _2]
            var rh = div [arg.r.size.h, _2]
        }
}

func isRectVsRect: [r1:Rect,r2:Rect] -> _int {
    return (or [ isPointVsRect [p1,r1],
            or [ isPointVsRect [p2,r1],
            or [ isPointVsRect [p3,r1],
                 isPointVsRect [p4,r1]]]])
        where {
            var r1 = arg.r1
            var r2 = arg.r2
            var w2 = div [r2.size.w,_2]
            var h2 = div [r2.size.h,_2]
            var p1 = Point [sub[r2.pos.x,w2], sub[r2.pos.y,h2]]
            var p2 = Point [sub[r2.pos.x,w2], add[r2.pos.y,h2]]
            var p3 = Point [add[r2.pos.x,w2], add[r2.pos.y,h2]]
            var p4 = Point [add[r2.pos.x,w2], sub[r2.pos.y,h2]]
        }
}

func pico_loop: () -> () {
    output Pico.Set.Auto _0
    var old: _int = _SDL_GetTicks ()
    loop {
        var now: _int = _SDL_GetTicks ()
        var dt   = sub [now,old]            -- dt   = now - old
        var togo = sub [_40, dt]            -- togo = 40 - dt
        if lte [togo,_0] {                  -- if togo<=0
            emit @GLOBAL Event.Frame _40
            output Pico.Clear
            emit @GLOBAL Event.Draw
            output Pico.Present
            set old = add [togo,now]
        } else {
            var e: Event = input Pico.Event.Timeout [_SDL_ANY,togo]
            emit @GLOBAL e
        }
    }
}

-------------------------------------------------------------------------------

native type _{
    void output_Pico (CEU_Output arg) {
        assert(arg.tag == CEU_OUTPUT_PICO);
        Pico_Output c = *(Pico_Output*)&arg;
        if (arg.Pico.tag==CEU_OUTPUT_PICO_SET && arg.Pico.Set.tag==CEU_OUTPUT_PICO_SET_ANCHOR) {
            c.Set.Anchor._1 = arg.Pico.Set.Anchor._1.tag;
            c.Set.Anchor._2 = arg.Pico.Set.Anchor._2.tag;
        }
        pico_output(c);
    }

    void toce (SDL_Event* e, CEU_Event* arg) {
        switch (e->type) {
            case SDL_KEYDOWN:
                *arg = (CEU_Event) {
                    .tag = CEU_EVENT_KEY,
                    .Key = {
                        .tag = CEU_EVENT_KEY_DOWN,
                        .Down = e->key.keysym.sym
                    }
                };
                break;
            case SDL_MOUSEBUTTONDOWN: {
                int bt = e->button.button;
                int x  = e->button.x;
                int y  = e->button.y;
                *arg = (CEU_Event) {
                    .tag = CEU_EVENT_MOUSE,
                    .Mouse = {
                        .tag = CEU_EVENT_MOUSE_BUTTON,
                        .Button = {
                            .tag = CEU_EVENT_MOUSE_BUTTON_DOWN,
                            .Down = {{x,y},bt}
                        }
                    }
                };
                break;
            }
            case SDL_MOUSEBUTTONUP: {
                int bt = e->button.button;
                int x  = e->button.x;
                int y  = e->button.y;
                *arg = (CEU_Event) {
                    .tag = CEU_EVENT_MOUSE,
                    .Mouse = {
                        .tag = CEU_EVENT_MOUSE_BUTTON,
                        .Button = {
                            .tag = CEU_EVENT_MOUSE_BUTTON_UP,
                            .Up = {{x,y},bt}
                        }
                    }
                };
                break;
            }
            case SDL_MOUSEMOTION: {
                int x  = e->button.x;
                int y  = e->button.y;
                *arg = (CEU_Event) {
                    .tag = CEU_EVENT_MOUSE,
                    .Mouse = {
                        .tag = CEU_EVENT_MOUSE_MOTION,
                        .Motion = {x,y}
                    }
                };
                break;
            }
        }
    }

    CEU_Event input_Pico_Event (CEU_Input arg) {
        SDL_Event e;
        assert(arg.tag == CEU_INPUT_PICO);
        assert(arg.Pico.tag == CEU_INPUT_PICO_EVENT);
        int ok = pico_input(&e, *((Pico_Input*)&arg));
        switch (arg.Pico.Event.tag) {
            case CEU_INPUT_PICO_EVENT_FOREVER:
                assert(ok);
            case CEU_INPUT_PICO_EVENT_TIMEOUT: {
                if (!ok) {
                    return (CEU_Event) {
                        .tag = CEU_EVENT_TIMER,
                        .Timer = arg.Pico.Event.Timeout._2
                    };
                }
                break;
            }
            default:
                assert(0 && "bug found");
        }
        CEU_Event s;
        toce(&e, &s);
        return s;
    }

    void input_Pico_Unit (CEU_Input arg) {
        SDL_Event e;
        assert(arg.tag == CEU_INPUT_PICO);
        switch (arg.Pico.tag) {
            case CEU_INPUT_PICO_DELAY: {
                int ok = pico_input(&e, *((Pico_Input*)&arg));
                assert(ok);
                break;
            }
            case CEU_INPUT_PICO_EVENT: {
                input_Pico_Event (arg);
                break;
            }
            default:
                assert(0 && "bug found");
        }
    }
}

call _pico_open ()
-- TODO: pico_close()
