`pico_init(1);`
defer {
    `pico_init(0);`
}

;; DATA / ENUM

data :XY = [x,y]
data :WH = [w,h]
data :Rect = [x,y,w,h]

data :Pico = [] {
    :Quit  = []
    :Frame = [ms]
    :Draw  = []
    :Key = [key] {
        :Dn = []
        :Up = []
    }
    :Mouse = [pos:XY] {
        :Motion = []
        :Button = [but] {
            :Dn = []
            :Up = []
        }
    }
}

enum {
    :HAnchor-Left  =`Left`,   :HAnchor-Center, :HAnchor-Right,
    :VAnchor-Bottom=`Bottom`, :VAnchor-Middle, :VAnchor-Top,
}

enum {
    :Key-A = `SDLK_a`,
    :Key-B, :Key-C, :Key-D, :Key-E, :Key-F, :Key-G, :Key-H, :Key-I, :Key-J,
    :Key-K, :Key-L, :Key-M, :Key-N, :Key-O, :Key-P, :Key-Q, :Key-R, :Key-S,
    :Key-T ,:Key-U, :Key-V, :Key-W, :Key-X, :Key-Y, :Key-Z,

    :Key-Right = `SDLK_RIGHT`,
    :Key-Left, :Key-Down, :Key-Up,

	:Key-Escape = `SDLK_ESCAPE`,
}

;; INPUT

var pico_input_delay
set pico_input_delay = func (ms) {
    `pico_input_delay($ms.Number);`
}

var pico_event_sdl_ceu = func (sdl, type) {
    var tp = :nil
    var v0 = 0
    var v1 = 0
    var v2 = 0
    ```
        SDL_Event* evt = (SDL_Event*) $sdl.Pointer;
        $tp.Tag = evt->type;
        switch (evt->type) {
            case SDL_KEYDOWN:
            case SDL_KEYUP:
                $v0.Tag  = evt->key.state;
                $v1.Tag  = evt->key.keysym.sym;
                $v1.type = CEU_VALUE_TAG;
                break;
            case SDL_MOUSEBUTTONDOWN:
            case SDL_MOUSEBUTTONUP:
                $v0.Number = evt->button.x;
                $v1.Number = evt->button.y;
                $v2.Tag    = evt->button.button;
                break;
            case SDL_MOUSEMOTION:
                $v0.Number = evt->button.x;
                $v1.Number = evt->button.y;
                break;
        }
    ```
    ifs tp {
        is `:tag SDL_QUIT`            -> :Pico.Quit []
        is `:tag SDL_MOUSEMOTION`     -> :Pico.Mouse.Motion [[v0,v1]]
        is `:tag SDL_MOUSEBUTTONDOWN` -> :Pico.Mouse.Button.Dn [[v0,v1],v2]
        is `:tag SDL_MOUSEBUTTONUP`   -> :Pico.Mouse.Button.Up [[v0,v1],v2]
        is `:tag SDL_KEYDOWN`         -> :Pico.Key.Dn [[v0,v1],nil]
        is `:tag SDL_KEYUP`           -> :Pico.Key.Up [[v0,v1],nil]
        else -> throw(:error)
    }
}

var pico_input_event
set pico_input_event = func (tag) {
    var sdl = `:pointer NULL`
    ```
        int tag_to_type (int tag) {
            switch (tag) {
                case CEU_TAG_Pico_Quit:
                    return SDL_QUIT;
                case CEU_TAG_Pico_Key_Dn:
                    return SDL_KEYDOWN;
                case CEU_TAG_Pico_Key_Up:
                    return SDL_KEYUP;
                case CEU_TAG_Pico_Mouse_Motion:
                    return SDL_MOUSEMOTION;
                case CEU_TAG_Pico_Mouse_Button_Dn:
                    return SDL_MOUSEBUTTONDOWN;
                case CEU_TAG_Pico_Mouse_Button_Up:
                    return SDL_MOUSEBUTTONUP;
                default:
                    assert(0 && "bug found : missing tag -> type");
            }
        }

        SDL_Event sdl;
        int type = tag_to_type($tag.Tag);
        pico_input_event(&sdl,type);
        $sdl.Pointer = &sdl;
    ```
    pico_event_sdl_ceu(sdl, type)
}

var pico_input_event_timeout
set pico_input_event_timeout = func (type, time) {
    var sdl = `:pointer NULL`
    var ok = false
    ```
        SDL_Event sdl;
        $ok.Bool = pico_input_event_timeout(&sdl,$type.Tag,$time.Number);
        $sdl.Pointer = &sdl;
    ```
    ok and pico_event_sdl_ceu(sdl, type)
}

;; OUTPUT

var pico_output_clear
set pico_output_clear = func () {
    `pico_output_clear();`
}

var pico_output_draw_image
set pico_output_draw_image = func (x,y,img,cache) {
    set cache = cache or (cache == nil)
    `_pico_output_draw_image_cache((SDL_Point){$x.Number,$y.Number}, (char*)$img.Dyn->Ncast.Vector.buf, $cache.Bool);`
}

var pico_output_draw_line
set pico_output_draw_line = func (p1,p2) {
    var x1 = p1[0]
    var y1 = p1[1]
    var x2 = p2[0]
    var y2 = p2[1]
    `pico_output_draw_line((SDL_Point){$x1.Number,$y1.Number},
                           (SDL_Point){$x2.Number,$y2.Number});`
}

var pico_output_draw_rect
set pico_output_draw_rect = func (rct) {
    var x = rct[0]
    var y = rct[1]
    var w = rct[2]
    var h = rct[3]
    `pico_output_draw_rect((SDL_Rect){$x.Number,$y.Number,$w.Number,$h.Number});`
}

var pico_output_draw_pixel
set pico_output_draw_pixel = func (x,y) {
    `pico_output_draw_pixel((SDL_Point){$x.Number,$y.Number});`
}

var pico_output_draw_text
set pico_output_draw_text = func (x,y,txt) {
    `pico_output_draw_text((SDL_Point){$x.Number,$y.Number}, $txt.Dyn->Ncast.Vector.buf);`
}

var pico_output_present
set pico_output_present = func () {
    `pico_output_present();`
}

var pico_output_write
set pico_output_write = func (txt) {
    `pico_output_write($txt.Dyn->Ncast.Vector.buf);`
}

var pico_output_writeln
set pico_output_writeln = func (txt) {
    `pico_output_writeln($txt.Dyn->Ncast.Vector.buf);`
}

;; STATE

;; GET

var pico_state_get_size
set pico_state_get_size = func () {
    var w = 0
    var h = 0
    ```
        SDL_Point sz;
        pico_state_get_size(&sz);
        $w.Number = sz.x;
        $h.Number = sz.y;
    ```
    [w,h]
}

var pico_state_get_size_image
set pico_state_get_size_image = func (img) {
    var w = 0
    var h = 0
    ```
        SDL_Point sz;
        pico_state_get_size_image((char*)$img.Dyn->Ncast.Vector.buf, &sz);
        $w.Number = sz.x;
        $h.Number = sz.y;
    ```
    [w,h]
}

;; SET

var pico_state_set_anchor
set pico_state_set_anchor = func (h,v) {
    `pico_state_set_anchor($h.Tag,$v.Tag);`
}

var pico_state_set_auto
set pico_state_set_auto = func (on) {
    `pico_state_set_auto($on.Bool);`
}

var pico_state_set_color_clear
set pico_state_set_color_clear = func (r,g,b,a) {
    `pico_state_set_color_clear((SDL_Color){$r.Number,$g.Number,$b.Number,$a.Number});`
}

var pico_state_set_color_draw
set pico_state_set_color_draw = func (r,g,b,a) {
    `pico_state_set_color_draw((SDL_Color){$r.Number,$g.Number,$b.Number,$a.Number});`
}

var pico_state_set_cursor
set pico_state_set_cursor = func (x,y) {
    `pico_state_set_cursor((SDL_Point){$x.Number,$y.Number});`
}

var pico_state_set_font
set pico_state_set_font = func (file, h) {
    `pico_state_set_font($file.Dyn->Ncast.Vector.buf,$h.Number);`
}

var pico_state_set_grid
set pico_state_set_grid = func (on) {
    `pico_state_set_grid($on.Bool);`
}

var pico_state_set_image_crop
set pico_state_set_image_crop = func (x,y,w,h) {
    if x == nil {
        `pico_state_set_image_crop((SDL_Rect){0,0,0,0});`
    } else {
        `pico_state_set_image_crop((SDL_Rect){$x.Number,$y.Number,$w.Number,$h.Number});`
    }
}

var pico_state_set_pan
set pico_state_set_pan = func (x,y) {
    `pico_state_set_pan((SDL_Point){$x.Number,$y.Number});`
}

var pico_state_set_size
set pico_state_set_size = func (w,h) {
    `pico_state_set_size((SDL_Point){$w.Number,$h.Number});`
}

var pico_state_set_size_image
set pico_state_set_size_image = func (w,h) {
    `pico_state_set_size_image((SDL_Point){$w.Number,$h.Number});`
}

var pico_state_set_size_pixel
set pico_state_set_size_pixel = func (w,h) {
    `pico_state_set_size_pixel((SDL_Point){$w.Number,$h.Number});`
}

var pico_state_set_title
set pico_state_set_title = func (title) {
    `pico_state_set_title($title.Dyn->Ncast.Vector.buf);`
}

;; AUX

func pico_point_vs_rect? (pt, r) {
    ifs {
        pt.0 < (r.0-(r.2/2)) -> false
        pt.0 > (r.0+(r.2/2)) -> false
        pt.1 < (r.1-(r.3/2)) -> false
        pt.1 > (r.1+(r.3/2)) -> false
        else                 -> true
    }
}

func pico_rect_vs_rect? (r1, r2) {
    ifs {
        pico_point_vs_rect?(p1,r1) -> true
        pico_point_vs_rect?(p2,r1) -> true
        pico_point_vs_rect?(p3,r1) -> true
        pico_point_vs_rect?(p4,r1) -> true
        else                      -> false
    } where {
        var p1 = [(r2.0-(r2.2/2)), (r2.1-(r2.3/2))]
        var p2 = [(r2.0-(r2.2/2)), (r2.1+(r2.3/2))]
        var p3 = [(r2.0+(r2.2/2)), (r2.1+(r2.3/2))]
        var p4 = [(r2.0+(r2.2/2)), (r2.1-(r2.3/2))]
    }
}

;; LOOP

var pico_loop
set pico_loop = func () {
    pico_state_set_auto(false)
    var old
    set old = `:number SDL_GetTicks()`
    while true { {:break}
        var now
        set now = `:number SDL_GetTicks()`
        var togo
        set togo = 40 - (now - old)
        if togo <= 0 {
            broadcast in :global, :Pico.Frame [40]
            pico_output_clear()
            broadcast in :global, :Pico.Draw []
            pico_output_present()
            set old = togo + now
        } else {
            var tmp = pico_input_event_timeout(`:tag SDL_ANY`,togo)
            if tmp {
                if tmp is :quit {
                    throw(:break)
                }
                broadcast in :global, tmp
            }
        }
    }
}
