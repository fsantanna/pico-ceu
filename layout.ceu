^["@/pico/pico.ceu"]

pico.set.font("tiny.ttf", 10)

val {{||}} = pico.pct-to-pos

func f (lay, n, t :Lim) {
    assert(lay[t.p1.l][t.p1.c] == n)
    val COL = #lay[0]
    val LIN = #lay
    loop l in {t.p1.l+1 => LIN{ {
        until lay[l][t.p1.c] /= n
        set t.p2.l = l
    }
    loop c in {t.p1.c+1 => COL{ {
        until lay[t.p1.l][c] /= n
        set t.p2.c = c
    }
    ;;println(n, t)
    loop l in {t.p1.l => t.p2.l} {
        loop c in {t.p1.c => t.p2.c} {
            assert(lay[l][c] == n)
        }
    }
    #[t] ++ ifs {
        (t.p2.c+1) < COL => f(lay, n+1, [[l',t.p2.c+1],[l',t.p2.c+1]]) where {
            val l' = loop l in {0 => LIN{ {
                until (lay[l][t.p2.c+1] == (n+1)) and l
            }
        }
        (t.p2.l+1) < LIN => f(lay, n+1, [[t.p2.l+1,c'],[t.p2.l+1,c']]) where {
            val c' = loop c in {0 => COL{ {
                until (lay[t.p2.l+1][c] == (n+1)) and c
            }
        }
        else => #[] ;; done
    }
}

task Layout (lay) {
    set pub = #[]

    val COL = #lay[0]
    val LIN = #lay
   
    data :LC = [l,c]
    data :Lim = [p1:LC, p2:LC]

    set pub = #[]
    loop l in {0 => LIN{ {
        loop c in {0 => COL{ {
            if lay[l][c] == #pub {
                val t :Lim = [[l,c],[nil,nil]]
                loop c' in {c => COL{ {
                    until lay[l][c'] /= #pub
                    set t.p2.c = c'
                }
                loop l' in {l => LIN{ {
                    until lay[l'][c] /= #pub
                    set t.p2.l = l'
                }
                set pub[+] = t
            }
        }
    }

    spawn {
        every :Pico.Draw {
println("-=-=-")
            loop [i,t:Lim] in pub->to.iter([:idx,:val]) {
                val dx  = t.p1.c + (((t.p2.c + 1) - t.p1.c) / 2)
                val dy  = t.p1.l + (((t.p2.l + 1) - t.p1.l) / 2)
                val px  = dx / COL
                val py  = dy / LIN
println(i, t, dx, dy, px, py, px||py)
                pico.output.draw.text(px||py, to.string(i))
            }
        }
    }

    ;;set pub = f(lay, 0, [[0,0],[0,0]])
    await(|false)
}

test {
    do {
        println(:1)
        val lay = [
            [0, 1]
        ]
        val t = spawn Layout(lay)
        ;;println(t.pub)
        assert(t.pub === #[
            [[0,0], [0,0]],
            [[0,1], [0,1]],
        ])
    }
    do {
        println(:2)
        val lay = [
            [0,0,1],
            [0,0,1],
            [2,2,3],
            [4,5,3],
        ]
        val t = spawn Layout(lay)
        println(t.pub)
        assert(t.pub === #[
            [[0,0],[1,1]],
            [[0,2],[1,2]],
            [[2,0],[2,1]],
            [[2,2],[3,2]],
            [[3,0],[3,0]],
            [[3,1],[3,1]]
        ])
    }
}

val lay = [
    [0,0,1],
    [0,0,1],
    [2,2,3],
    [4,5,3],
]
val t = spawn Layout(lay)

pico.loop()
