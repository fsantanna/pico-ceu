^["@/pico/pico.ceu"]

pico.set.font("tiny.ttf", 10)

val {{||}} = pico.pct-to-pos

task Layout (lay) {
    set pub = #[]

    val COL = #lay[0]
    val LIN = #lay
   
    set pub = #[]
    loop l in {0 => LIN{ {
        loop c in {0 => COL{ {
            if lay[l][c] == #pub {
                val r :Rect = [[c,l],[nil,nil]]
                loop c' in {c => COL{ {
                    until lay[l][c'] /= #pub
                    set r.dim.w = (c' - r.pos.x) + 1
                }
                loop l' in {l => LIN{ {
                    until lay[l'][c] /= #pub
                    set r.dim.h = (l' - r.pos.y) + 1
                }
                set pub[+] = r
            }
        }
    }

    spawn {
        every :Pico.Draw {
;;println("-=-=-")
            val [_,[W,H]] = pico.get.size()
            pico.set.anchor(:HAnchor-Left, :VAnchor-Top)
            loop [i,t:Rect] in pub->to.iter([:idx,:val]) {
;;println(i, t, dx, dy, px, py, px||py)
                val px = W / COL
                val py = H / LIN
                val r = [[t.pos.x*px, t.pos.y*py], [t.dim.w*px, t.dim.h*py]]
;;println(i, px, py, r)
                pico.output.draw.rect(r)
            }
        }
    }

    ;;set pub = f(lay, 0, [[0,0],[0,0]])
    await(|false)
}

test {
    do {
        println(:1)
        val lay = [
            [0, 1]
        ]
        val t = spawn Layout(lay)
        println(t.pub)
        assert(t.pub === #[
            [[0,0], [1,1]],
            [[1,0], [1,1]],
        ])
    }
    do {
        println(:2)
        val lay = [
            [0,0,1],
            [0,0,1],
            [2,2,3],
            [4,5,3],
        ]
        val t = spawn Layout(lay)
        println(t.pub)
        assert(t.pub === #[
            [[0,0],[2,2]],
            [[2,0],[1,2]],
            [[0,2],[2,1]],
            [[2,2],[1,2]],
            [[0,3],[1,1]],
            [[1,3],[1,1]]
        ])
    }
}

val lay = [
    [0,0,1],
    [0,0,1],
    [2,2,3],
    [4,5,3],
]
val t = spawn Layout(lay)

pico.loop()
