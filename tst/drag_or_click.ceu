^"prelude.ceu"
^"int.ceu"
^"pico.ceu"

var rect: Rect = [[_10,_10],[_5,_5]]

spawn {
    loop {
        var dxy: Size --= do {
        {
            var mouse: Point
            await evt?Mouse?Button?Down until isPointVsRect [mouse,rect]
                where {
                    set mouse = evt!Mouse!Button!Down.pos
                }
            --return [sub [rect.pos.x,mouse.x], sub [rect.pos.y,mouse.y]]
            set dxy = [sub [rect.pos.x,mouse.x], sub [rect.pos.y,mouse.y]]
        }
        paror {
            var orig = rect
            await evt?Key?Down until eq [evt!Key!Down.key,_SDLK_ESCAPE]
            set rect = orig
            output Std _("Cancelled!"):_(char*)
        } with {
            await evt?Mouse?Motion
            output Std _("Dragging..."):_(char*)
            var mouse = evt!Mouse!Motion
            watching evt?Mouse?Button?Up {
                loop {
                    set rect = [pt, rect.size]
                        where {
                            var pt: Point = [add [mouse.pos.x,dxy.w], add [mouse.pos.y,dxy.h]]
                        }
                    await evt?Mouse?Motion
                    set mouse = evt!Mouse!Motion
                }
            }
            output Std _("Dropped!"):_(char*)
        } with {
            await evt?Mouse?Button?Up
            output Std _("Clicked!"):_(char*)
        }
    }
}

spawn {
    loop {
        await _1
        output Pico.Clear
        output Pico.Draw.Rect rect
        output Pico.Present
    }
}

call pico_loop ()
