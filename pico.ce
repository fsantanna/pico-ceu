type Point = [x:_int, y:_int]
type Size  = [w:_int, h:_int]
type Rect  = [pos:Point, size:Size]

type THAnchor = <ULeft  =(),UCenter=(),URight=()>
type TVAnchor = <UBottom=(),UMiddle=(),UTop  =()>

type Event = <
    UKill            = (),
    UTask            = _uint64_t,
    UAny             = (),
    UTimeout         = (),
    UFrame           = _int,
    UDraw            = (),
    UKeyDown         = _int,
    UMouseButtonDown = [but:_int,pos:Point],
    UMouseButtonUp   = [_int,Point],
    UMouseMotion     = Point,
    UCollided        = (),
    UPause           = _int,
    UHide            = _int
>

type TPico = <
    UDelay           = _int,
    UEvent           = _int,
    UEvent_Timeout   = [_int,_int],
    UPresent         = (),
    UClear           = (),
    UDraw_Pixel      = Point,
    UDraw_Line       = [Point,Point],
    UDraw_Rect       = Rect,
    UDraw_Text       = [Point,_(char*)],
    UDraw_Image      = [Point,_(char*)],
    UGet_Size        = /Size,
    USet_Anchor      = [THAnchor,TVAnchor],
    USet_Auto        = (),
    USet_Color_Clear = [_int,_int,_int,_int],
    USet_Color_Draw  = [_int,_int,_int,_int],
    USet_Cursor      = Point,
    USet_Font        = [_(char*),_int],
    USet_Grid        = _int,
    USet_Pan         = Point,
    USet_Size        = Size,
    USet_Title       = _(char*),
    USet_Zoom        = Size,
    UWrite           = _(char*),
    UWriteLn         = _(char*)
>

-------------------------------------------------------------------------------

var isPointVsRect = func [pt:Point,r:Rect] -> _int {
    return not (or [ lt [pt.x, sub [r.x,rw]],
                or [ gt [pt.x, add [r.x,rw]],
                or [ lt [pt.y, sub [r.y,rh]],
                     gt [pt.y, add [r.y,rh]]]]])
        where {
            var pt = arg.pt
            var r  = arg.r.pos
            var rw = div [arg.r.size.w, _2]
            var rh = div [arg.r.size.h, _2]
        }
}

var isRectVsRect = func [r1:Rect,r2:Rect] -> _int {
    return (or [ isPointVsRect [p1,r1],
            or [ isPointVsRect [p2,r1],
            or [ isPointVsRect [p3,r1],
                 isPointVsRect [p4,r1]]]])
        where {
            var r1 = arg.r1
            var r2 = arg.r2
            var w2 = div [r2.size.w,_2]
            var h2 = div [r2.size.h,_2]
            var p1 = Point [sub[r2.pos.x,w2], sub[r2.pos.y,h2]]
            var p2 = Point [sub[r2.pos.x,w2], add[r2.pos.y,h2]]
            var p3 = Point [add[r2.pos.x,w2], add[r2.pos.y,h2]]
            var p4 = Point [add[r2.pos.x,w2], sub[r2.pos.y,h2]]
        }
}

var pico_loop = func () -> () {
    output pico TPico.USet_Auto _0
    var old: _int = _SDL_GetTicks ()
    loop {
        var now: _int = _SDL_GetTicks ()
        var dt   = sub [now,old]            -- dt   = now - old
        var togo = sub [_40, dt]            -- togo = 40 - dt
        if lte [togo,_0] {                  -- if togo<=0
            emit @GLOBAL Event.UFrame _40
            output pico TPico.UClear
            emit @GLOBAL Event.UDraw
            output pico TPico.UPresent
            set old = add [togo,now]
        } else {
            var e: Event = input pico TPico.UEvent_Timeout [_SDL_ANY,togo]
            if not e?UTimeout {
                emit @GLOBAL e
            }
        }
    }
}

-------------------------------------------------------------------------------

native type _{
    void output_pico (TPico arg) {
        switch (arg.tag) {
            case USet_Anchor: {
                // TODO: _12
                Pico_IO io = { PICO_SET_ANCHOR, .Set_Anchor = {arg._12._1.tag,arg._12._2.tag} };
                pico_output(io);
                break;
            }
            default:
                pico_output(*(Pico_IO*)&arg);
                break;
        }
    }

    int tosdl (int e) {
        switch (e) {
            case UAny:              return SDL_ANY;
            //case UTimeout:          return ???;
            case UKeyDown:          return SDL_KEYDOWN;
            case UMouseButtonDown:  return SDL_MOUSEBUTTONDOWN;
            case UMouseButtonUp:    return SDL_MOUSEBUTTONUP;
            case UMouseMotion:      return SDL_MOUSEMOTION;
        }
        assert(0);
    }

    void toce (SDL_Event* e, Event* arg) {
        switch (e->type) {
            case SDL_KEYDOWN:
                // TODO: _7
                *arg = (Event) { UKeyDown, { ._7 = e->key.keysym.sym } };
                break;
            case SDL_MOUSEBUTTONDOWN: {
                int bt = e->button.button;
                int x  = e->button.x;
                int y  = e->button.y;
                // TODO: _8
                *arg = (Event) { UMouseButtonDown, { ._8 = {bt,{x,y}} } };
                break;
            }
            case SDL_MOUSEBUTTONUP: {
                int bt = e->button.button;
                int x  = e->button.x;
                int y  = e->button.y;
                // TODO: _9
                *arg = (Event) { UMouseButtonUp, { ._9 = {bt,{x,y}} } };
                break;
            }
            case SDL_MOUSEMOTION: {
                int x  = e->button.x;
                int y  = e->button.y;
                // TODO: _10
                *arg = (Event) { UMouseMotion, { ._10 = {x,y} } };
                break;
            }
        }
    }

    Event input_pico_Event (TPico arg) {
        SDL_Event e;
        switch (arg.tag) {
            case UEvent: {
                // TODO: _2
                int ok = pico_input(&e, (Pico_IO) {PICO_EVENT,.Event=arg._2});
                assert(ok);
                Event s;
                toce(&e, &s);
                return s;
            }
            case UEvent_Timeout: {
                // TODO: _3
                int ok = pico_input(&e, (Pico_IO) {
                    PICO_EVENT_TIMEOUT,
                    .Event_Timeout = { arg._3._1, arg._3._2 }
                });
                if (ok) {
                    Event s;
                    toce(&e, &s);
                    return s;
                } else {
                    return (Event) { UTimeout };
                }
                break;
            }
        }
    }

    void input_pico_Unit (TPico arg) {
        SDL_Event e;
        switch (arg.tag) {
            case UDelay: {
                int ok = pico_input(&e, *((Pico_IO*)&arg));
                assert(ok);
                break;
            }
            default:
                input_pico_Event (arg);
                break;
        }
    }
}

call _pico_open ()
-- TODO: pico_close()
