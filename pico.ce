type Point = [_int,_int]
type Dims  = [_int,_int]
type Rect  = [Point,Dims]

-- ULeft,   UCenter, URight
-- UBottom, UMiddle, UTop
type THAnchor = <(),(),()>
type TVAnchor = <(),(),()>

type Event = <
    ()          ,   -- EVENT_KILL
    _uint64_t   ,   -- EVENT_TASK
    ()          ,   -- UAny
    ()          ,   -- UTimeout
    _int        ,   -- UKeyDown
    [_int,Point],   -- UMouseButtonDown
    [_int,Point],   -- UMouseButtonUp
    [_int,_int]     -- UMouseMotion
>

type TPico = <
    _int                 , -- UDelay
    _int                 , -- UEvent
    [_int,_int]          , -- UEvent_Timeout
    ()                   , -- UPresent
    ()                   , -- UClear
    Point                , -- UDraw_Pixel
    [Point,Point]        , -- UDraw_Line
    Rect                 , -- UDraw_Rect
    [Point,_(char*)]     , -- UDraw_Text
    [Point,_(char*)]     , -- UDraw_Image
    /Dims                , -- UGet_Size
    [THAnchor,TVAnchor]  , -- USet_Anchor
    ()                   , -- USet_Auto
    [_int,_int,_int,_int], -- USet_Color_Clear
    [_int,_int,_int,_int], -- USet_Color_Draw
    Point                , -- USet_Cursor
    [_(char*),_int]      , -- USet_Font
    _int                 , -- USet_Grid
    Point                , -- USet_Pan
    Dims                 , -- USet_Size
    _(char*)             , -- USet_Title
    Dims                 , -- USet_Zoom
    _(char*)             , -- UWrite
    _(char*)               -- UWriteLn 
>

-- xTPico
#define UDelay              1
#define UEvent              2
#define UEvent_Timeout      3
#define UPresent            4
#define UClear              5
#define UDraw_Pixel         6
#define UDraw_Line          7
#define UDraw_Rect          8
#define UDraw_Text          9
#define UDraw_Image         10
#define UGet_Size           11
#define USet_Anchor         12
#define USet_Auto           13
#define USet_Color_Clear    14
#define USet_Color_Draw     15
#define USet_Cursor         16
#define USet_Font           17
#define USet_Grid           18
#define USet_Pan            19
#define USet_Size           20
#define USet_Title          21
#define USet_Zoom           22
#define UWrite              23
#define UWriteLn            24

-- xEvent
--#define KILL                1
--#define TASK                2
#define UAny                3
#define UTimeout            4
#define UKeyDown            5
#define UMouseButtonDown    6
#define UMouseButtonUp      7
#define UMouseMotion        8

-- xAnchor
#define ULeft       1
#define UCenter     2
#define URight      3
#define UBottom     1
#define UMiddle     2
#define UTop        3

-------------------------------------------------------------------------------

var isPointInsideRect = func [Point,Rect] -> _int {
    return not (or [ lt [mx, sub [rx,rw]],
                or [ gt [mx, add [rx,rw]],
                or [ lt [my, sub [ry,rh]],
                     gt [my, add [ry,rh]]]]])
        where {
            var mx = arg.1.1
            var my = arg.1.2
            var rx = arg.2.1.1
            var ry = arg.2.1.2
            var rw = div [arg.2.2.1, _2]
            var rh = div [arg.2.2.2, _2]
        }
}

var pico_loop = func () -> () {
    output pico TPico.USet_Auto _0
    loop {
        var e: Event = input pico TPico.UEvent_Timeout [_SDL_ANY,_33]
        emit e
    }
}

-------------------------------------------------------------------------------

native type _{
    void output_pico (TPico arg) {
        switch (arg.tag) {
            case USet_Anchor: {
                // TODO: _12
                Pico_IO io = { PICO_SET_ANCHOR, .Set_Anchor = {arg._12._1.tag,arg._12._2.tag} };
                pico_output(io);
                break;
            }
            default:
                pico_output(*(Pico_IO*)&arg);
                break;
        }
    }

    int tosdl (int e) {
        switch (e) {
            case UAny:              return SDL_ANY;
            //case UTimeout:          return ???;
            case UKeyDown:          return SDL_KEYDOWN;
            case UMouseButtonDown:  return SDL_MOUSEBUTTONDOWN;
            case UMouseButtonUp:    return SDL_MOUSEBUTTONUP;
            case UMouseMotion:      return SDL_MOUSEMOTION;
        }
        assert(0);
    }

    void toce (SDL_Event* e, Event* arg) {
        switch (e->type) {
            case SDL_KEYDOWN:
                // TODO: _5
                *arg = (Event) { UKeyDown, { ._5 = e->key.keysym.sym } };
                break;
            case SDL_MOUSEBUTTONDOWN: {
                int bt = e->button.button;
                int x  = e->button.x;
                int y  = e->button.y;
                // TODO: _6
                *arg = (Event) { UMouseButtonDown, { ._6 = {bt,{x,y}} } };
                break;
            }
            case SDL_MOUSEBUTTONUP: {
                int bt = e->button.button;
                int x  = e->button.x;
                int y  = e->button.y;
                // TODO: _7
                *arg = (Event) { UMouseButtonUp, { ._7 = {bt,{x,y}} } };
                break;
            }
            case SDL_MOUSEMOTION: {
                int x  = e->button.x;
                int y  = e->button.y;
                // TODO: _8
                *arg = (Event) { UMouseMotion, { ._8 = {x,y} } };
                break;
            }
        }
    }

    Event input_pico_Event (TPico arg) {
        SDL_Event e;
        switch (arg.tag) {
            case UEvent: {
                // TODO: _2
                int ok = pico_input(&e, (Pico_IO) {PICO_EVENT,.Event=arg._2});
                assert(ok);
                Event s;
                toce(&e, &s);
                return s;
            }
            case UEvent_Timeout: {
                // TODO: _3
                int ok = pico_input(&e, (Pico_IO) {
                    PICO_EVENT_TIMEOUT,
                    .Event_Timeout = { arg._3._1, arg._3._2 }
                });
                if (ok) {
                    Event s;
                    toce(&e, &s);
                    return s;
                } else {
                    return (Event) { UTimeout };
                }
                break;
            }
        }
    }

    void input_pico_Unit (TPico arg) {
        SDL_Event e;
        switch (arg.tag) {
            case UDelay: {
                int ok = pico_input(&e, *((Pico_IO*)&arg));
                assert(ok);
                break;
            }
            default:
                input_pico_Event (arg);
                break;
        }
    }
}

call _pico_open ()
-- TODO: pico_close()
